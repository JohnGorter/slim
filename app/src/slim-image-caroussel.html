<dom-module id="slim-image-caroussel">
    <template>
        <style>
            h1.title { position:relative;top:0px;text-align:left;margin-left:20px;align-self:flex-start;width:100vw;height:30px;color:white;z-index:99;font-family:tahoma;font-size:20px;font-weight:normal;text-shadow: 2px 2px black;font-variant-caps: small-caps;}
            h1.details { position:relative;top:500px;text-align:right;margin-right:20px;align-self:flex-end;width:100vw;height:30px;color:white;z-index:99;font-family:tahoma;font-size:12px;font-weight:normal;}
            #container { position:fixed ;display:flex;align-items:flex-start;justify-content:flex-start;flex-flow:column;width:100vw;height:90vh;background-color:#303030}
            .image { -webkit-transform: translate3d(0,0,0);position:absolute;width:100vw;height:80vh;}
            .image.moving {position:absolute;width:100vw;height:500px;opacity:1}
            canvas { z-index: 101;}
        </style>
        <div id="container">
            
              <template is="dom-if" if="{{userprofile.isAdmin}}">
                <paper-toolbar style="width:100vw;top:500px;">
                    <span slot="top" class="title"> </span>
                    <paper-icon-button slot="top" icon="undo" on-tap="_undo"></paper-icon-button>
                    <paper-icon-button slot="top" icon="image:rotate-90-degrees-ccw" on-tap="_rotate"></paper-icon-button>
                    <paper-icon-button slot="top" icon="invert-colors" on-tap="_grayscale"></paper-icon-button>
                    <paper-icon-button slot="top" icon="delete" on-tap="_deleteConfirm"></paper-icon-button>
                </paper-toolbar>
            </template> 

             <canvas id="canvas" hidden width="0" height="0" style="border:2px solid red;z-index:110;">hier</canvas> 

            <paper-dialog id="modal" modal on-iron-overlay-opened="patchOverlay">
                <p>Bevesting het verwijderen van de foto. Weet u het zeker? </p>
                <div class="buttons">
                    <paper-button dialog-confirm autofocus on-tap="_delete">Ja, verwijder!</paper-button>
                    <paper-button dialog-confirm autofocus>Annuleren</paper-button>
                </div>
            </paper-dialog>

              <firebase-document app-name="slimapp" data="{{fbPhoto}}" path="/photos/{{selectedPhoto.$key}}"></firebase-document>


            </firebase-document>

            <template is="dom-if" if="{{!_isDone(renderedItemCount)}}">
                <img style="position:relative;height:50px;align-self:center;top:25%;" src="./images/loading.svg" />
            </template>

            <template is="dom-repeat" items="{{images}}" rendered-item-count="{{renderedItemCount}}" initialCount="1">
                    <div class="image" alt$="{{item.title}}" style$='background:url("{{item.photo}}") no-repeat center center;background-size: contain;height:480px;width:100vw;z-index:{{index}};background-color:#303030'></div>
            </template>
         
            <h1 class="title" id="title"></h1>
            <h1 class="details" id="details"></h1>
        </div>
    </script>
    </body>
</html>
    </template>
    <script>
    var player;
    var origleft;
    var finishpos = 0;
    var a = [];
    var interval;
    var i = 0;
    var ang = 90; //angle

    Polymer({
        observers:['_getImages(renderedItemCount)'],
        properties:{
            selectedPhoto:{
                type:Number, 
                value:0
            },
            images:{
                type:Array, 
                notify:true 
            }
        },
        is:'slim-image-caroussel',
        _grayscale()
        {
            var myCanvasContext = this.$.canvas.getContext("2d");
            var img = new Image();
            img.onload = () => {
                var imgWidth=img.width;
                var imgHeight=img.height;
                // You'll get some string error if you fail to specify the dimensions
                this.$.canvas.width= imgWidth;
                this.$.canvas.height=imgHeight;
                //  alert(imgWidth);
                myCanvasContext.drawImage(img,0,0);

                // This function cannot be called if the image is not rom the same domain.
                // You'll get security error if you do.
                var imageData=myCanvasContext.getImageData(0,0, imgWidth, imgHeight);

                // This loop gets every pixels on the image and
               for (var i = 0; i < imageData.data.length; i+=4) {
                    var redPx = imageData.data[i];
                    var greenPx = imageData.data[i+1];
                    var bluePx = imageData.data[i+2];
                    var alphaPx = imageData.data[i+3];

                    var greyScale = redPx * .3 + greenPx * .59 + bluePx * .11;

                    imageData.data[i] = greyScale;
                    imageData.data[i+1] = greyScale;
                    imageData.data[i+2] = greyScale;
                    imageData.data[i+3] = alphaPx;
                }

                myCanvasContext.putImageData(imageData, 0,0);
                this._save();
            }
            img.src = this.selectedPhoto.photo;
        },

        _rotate(){
            // ang = 90; 
            // if (ang >= 360) ang = 0;

            var ctx = this.$.canvas.getContext('2d');
            var img = new Image();

            var fps = 1000 / 25; //number of frames per sec
            img.onload = function () { //on image load do the following stuff
                var width = this.$.canvas.width == 0 ? img.width : this.$.canvas.width;
                var height = this.$.canvas.height == 0 ? img.height: this.$.canvas.height;
                console.log('img is ', width, height);
                this.$.canvas.width = height;
                this.$.canvas.height = width;
                console.log('setting canvas to ', this.$.canvas.width, this.$.canvas.height);
                ctx.save(); //saves the state of canvas
                ctx.clearRect(0, 0, this.$.canvas.width, this.$.canvas.height); //clear the canvas
                ctx.translate(this.$.canvas.width/2, this.$.canvas.height/2,); //let's translate
                ctx.rotate(Math.PI / 180 * (ang)); //increment the angle and rotate the image 
                ctx.drawImage(img,-img.width/2,-img.height/2, img.width, img.height);
                ctx.restore(); //restore the state of canvas
                this._save();
            }.bind(this);
            img.src = this.selectedPhoto.photo;
        },
        _undo(){
            this.set('fbPhoto.photo', this.fbPhoto.previous);
        },
        _save(){
            this.set('fbPhoto.previous', this.fbPhoto.photo); //remember the previous photo
            this.set('fbPhoto.photo', this.$.canvas.toDataURL());
        },
        _deleteConfirm(){
            this.$.modal.open();
        },
        _delete(){
           this.fire('photo-delete', {photo:this.selectedPhoto});
        },
        ready(){
          // let repeater finish...
          this.async(() => {
            this.listen(this, 'track', '_track');
          });
        },
        getImages(){
            a = [];
            var i = 0;
            const slot = Polymer.dom(this.root).querySelectorAll(".image");
            slot.forEach(function(element) {
                if (element.nodeType == 1) {
                    a.push(element);
                }
            }, this);
            this.selectedPhoto = this.images[this.images.length-1];
        },
        _getImages(){
            this.getImages();       
            this._updateDetails();     
        },
    _isDone(){
        return this.renderedItemCount != 0;
    },
        patchOverlay(e) {
            if (e.target.withBackdrop) {
                e.target.parentNode.insertBefore(e.target.backdropElement, e.target);
            }
        },
        sortImages(){
            Array.prototype.slice.call(a).sort(function (a, b) {
                return a.style.zIndex > b.style.zIndex;
            });
        },
        addClass(elem, name) {
            if (!elem.classList.contains(name)){
                elem.className += " " + name;
            }
        },
        removeClass(elem, name) {
            elem.className = elem.className.replace(name, '');
        },
         _track(){
             var element;
             if (event.path)
                 element = event.path[0];
            else
                element = this._getTopMostImage();
            // only track images
            if (element.className.indexOf("image") < 0) return;

            if (event.detail.state == 'start'){
               origleft = element.style.left ?  element.style.left :0;
            }
            this.addClass(element, 'moving');
            newint = parseInt(origleft) + parseInt(event.detail.dx);
            element.style.left = `${newint}px`;
            if (event.detail.state == 'end'){
                this.completeGesture(element);
                this.removeClass(element, 'moving');
            }
        },
        completeGesture(elem){
            if (player != undefined) return;
            var center = (elem.getBoundingClientRect().width/2) + elem.getBoundingClientRect().left;
            var windowcenter = window.innerWidth /10;
            var elementcenter = (windowcenter * 5) - (elem.getBoundingClientRect().width/2);
            var direction = center < windowcenter ? -400: center > (windowcenter * 9) ? 1400: parseInt((elementcenter - elem.getBoundingClientRect().left));
            finishpos = direction == -400? -1: direction == 1400 ? 1 : 0;
            player = elem.animate([
                {transform:'translateX(0px)'},
                {transform:'translateX(' + direction + 'px)'}
            ], {
                duration: 400,
                iterations: 1,
                delay: 0,
            });

            player.onfinish = () => {
                player = undefined;
                var width = elem.getBoundingClientRect().width;
                elem.style.display = 'none';
                elem.style.left = finishpos < 0 ? '-400px' : finishpos > 0 ? '1400px': ((window.innerWidth/2) - (width/2)) + 'px';
                this.removeClass(elem,'moving');
                if (finishpos != 0) {
                    this.sortImages();
                    for (var i = 0; i < a.length; i++)
                    {
                        a[i].style.zIndex = parseInt(a[i].style.zIndex) + 1;
                        a[i].style.left = ((window.innerWidth/2) - (width/2)) + 'px';
                    }
                    elem.style.zIndex = -1;
                    var nextelement = this._getTopMostImage();
                    this.selectedPhoto = nextelement.__templatizeInstance.item;
                }
                elem.style.display = 'block';
                
                this._updateDetails();
                };
        },
         _updateDetails(){
            var e = this._getTopMostImage();
            if (e && e.attributes && e.attributes["alt"]){
               this.$.title.innerHTML = e.attributes["alt"].value;
            } else {
                this.$.title.innerHTML = "";
            }
            this.$.details.innerHTML = "Foto " + (a.length - a.indexOf(e)) + " van " + a.length + "";// + e.attributes["alt"].value;
         },
         _getTopMostImage(){
              // get the highest zindex
            var e = a[0];
            for (var i = 1; i < a.length; i++)
                if (a[i].style.zIndex > e.style.zIndex) e = a[i];
            return e;
         }
    })
    </script>
</dom-module>