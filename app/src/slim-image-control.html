<dom-module id="slim-image-control">
    <template>
        <style>
            :host { z-index: 10;width:100%;}
        </style>
        <!-- hidden canvas for image manipulation -->
        <input hidden="true" type="file" id="btnpic" accept="image/*" on-change="_loadPhoto">
        
        <!-- image manipulation toolbar -->
        <paper-toolbar width="100%">
            <paper-icon-button on-tap="_takepicture" slot="top"   icon="image:camera-alt"></paper-icon-button>
            <div slot="top" class="title">{{title}}</div>
            <paper-icon-button slot="top" icon="undo" on-tap="_undo"></paper-icon-button>
            <paper-icon-button slot="top" icon="image:rotate-90-degrees-ccw" on-tap="_rotate"></paper-icon-button>
            <paper-icon-button slot="top" icon="invert-colors" on-tap="_grayscale"></paper-icon-button>
            <paper-icon-button slot="top" icon="delete" on-tap="_deleteConfirm"></paper-icon-button>
             <paper-icon-button on-tap="_save"  slot="top" icon="save">Foto toevoegen</paper-icon-button>
        </paper-toolbar>
       
        <canvas id="canvas" hidden$="{{!preview}}" width="0" height="0" style="z-index:111;">hier</canvas> 
        
         <!-- delete confirmation dialog -->
         <paper-dialog id="modal" modal on-iron-overlay-opened="_patchOverlay">
            <p>Bevesting het verwijderen van de foto. Weet u het zeker? </p>
            <div class="buttons">
                <paper-button dialog-confirm autofocus on-tap="_delete">Ja, verwijder!</paper-button>
                <paper-button dialog-confirm autofocus>Annuleren</paper-button>
            </div>
        </paper-dialog>

    </template>
    <script>
    Polymer({
      is:'slim-image-control',
      properties:{
          title:{
              type:String,
              value:'photo'
          },
          undostack:{
              type:Array,
              value:[]
          },
         photo:{
            type:String,
            notify:true,
            observer:'_updateCanvas'
        },
        preview:{
            type:Boolean,
            value:false
        }
      },
      _deleteConfirm(){
            this.$.modal.open();
        },
        _delete(){
           this.set('photo','');
           this.set('undostack', []);
           this.fire('photo-delete', { photo:this.photo});
        },
        _save(){
            this.fire('photo-save', { photo:this.photo});
        },
      _takepicture(){
          this.$.btnpic.click();
      },
      _updateCanvas(){
          this.$.canvas.hidden = !(this.photo != "" && this.preview);
          if (this.photo != ""){
            this.set('undostack', []);
            setTimeout(()=>{
                this.$.canvas.getContext("2d").clearRect(0, 0, this.$.canvas.width, this.$.canvas.height);
                var img = document.createElement("img");
                img.onload = () => {
                    this._drawCanvas(img);
                };
                img.src = this.photo;
            },10);
          }
      },
      _drawCanvas(img){
        this.$.canvas.hidden = !(this.photo != "" && this.preview);
        var ctx =  this.$.canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);

        var MAX_WIDTH = 400;
        var MAX_HEIGHT = 300;
        var width = img.width;
        var height = img.height;

        if (width > height) {
            if (width > MAX_WIDTH) {
                height *= MAX_WIDTH / width;
                width = MAX_WIDTH;
            }
        } else {
            if (height > MAX_HEIGHT) {
                width *= MAX_HEIGHT / height;
                height = MAX_HEIGHT;
            }
        }
        this.$.canvas.width = width;
        this.$.canvas.height = height;
        var ctx = this.$.canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, width, height);
      },
      _loadPhoto(e){
            var data = e.target.files[0];
            var reader = new FileReader();
            var img = document.createElement("img");
            reader.onload = function(evt){
                img.src = reader.result;
                img.onload = () => {
                   this._drawCanvas(img);
                   this._updatePhoto();
                };
            }.bind(this);
            reader.readAsDataURL(data);
      },
       _grayscale()
        {
            if (!this.photo){ return; }
            var myCanvasContext = this.$.canvas.getContext("2d");
            var img = new Image();
            img.onload = () => {
                var imgWidth=img.width;
                var imgHeight=img.height;
                this.$.canvas.width= imgWidth;
                this.$.canvas.height=imgHeight;
                myCanvasContext.drawImage(img,0,0);
                var imageData=myCanvasContext.getImageData(0,0, imgWidth, imgHeight);
                // This loop gets every pixels on the image and
               for (var i = 0; i < imageData.data.length; i+=4) {
                    var redPx = imageData.data[i];
                    var greenPx = imageData.data[i+1];
                    var bluePx = imageData.data[i+2];
                    var alphaPx = imageData.data[i+3];
                    var greyScale = redPx * .3 + greenPx * .59 + bluePx * .11;
                    imageData.data[i] = greyScale;
                    imageData.data[i+1] = greyScale;
                    imageData.data[i+2] = greyScale;
                    imageData.data[i+3] = alphaPx;
                }
                myCanvasContext.putImageData(imageData, 0,0);
                this._updatePhoto();
            }
            img.src = this.photo;
        },
        _rotate(){
            if (!this.photo){ return; }
            var ctx = this.$.canvas.getContext('2d');
            var img = new Image();
            img.onload = function () { //on image load do the following stuff
                var width = this.$.canvas.width == 0 ? img.width : this.$.canvas.width;
                var height = this.$.canvas.height == 0 ? img.height: this.$.canvas.height;
                this.$.canvas.width = height;
                this.$.canvas.height = width;
                ctx.save(); //saves the state of canvas
                ctx.clearRect(0, 0, this.$.canvas.width, this.$.canvas.height); //clear the canvas
                ctx.translate(this.$.canvas.width/2, this.$.canvas.height/2,); //let's translate
                ctx.rotate(Math.PI / 180 * (ang)); //increment the angle and rotate the image 
                ctx.drawImage(img,-img.width/2,-img.height/2, img.width, img.height);
                ctx.restore(); //restore the state of canvas
                this._updatePhoto();
            }.bind(this);
            img.src = this.photo;
        },
        _updatePhoto(){
            this.push('undostack', this.photo);
            var stack = this.undostack;
            this.set('photo', this.$.canvas.toDataURL());
            this.undostack = stack; // reset the undostack 
            console.log('the undostack', this.undostack);
        },
        _undo(){
            if (this.undostack.length > 0){
                var stack = this.undostack;
                this.set('photo', this.undostack[this.undostack.length-1]);
                this.undostack = stack; // reset the undostack 
                this.splice('undostack', this.undostack.length-1,1);
            }
        },
    
        _patchOverlay(e) {
            if (e.target.withBackdrop) {
                e.target.parentNode.insertBefore(e.target.backdropElement, e.target);
            }
        },
    })
    </script>
</dom-module>